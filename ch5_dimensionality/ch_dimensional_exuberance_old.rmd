# 5. Finding patterns in data

Movements in machine learning: patterns of generalization
Dimensional exuberance and pattern recognition in movement

```{r echo=FALSE} 
library(knitr)
opts_chunk$set(results='asis', message=FALSE, warnings=FALSE, cache=TRUE)
```

## to do
- the archaeology brings us to 70-80-90-2000; decision tree, neural network, support vector machine; examples of what happened in late 20th century machines
- support vector machine as the first machine learner that actually made 'machine' in the name
- Hinton doing a google tech talk -- the men in the room; his description of what has changed;
- the general point of this chapter: what is going into the data? 
- add Quinlan 1986 on how experts can't really interpret the trees
- maybe this is the main point with in this chapter -- dimensionality != comprehensibility; how these techniques produce confusion or perplexity in themselves, not because of anything about their usage
- recap on functions, gradient descent, optimization and regression -- what do they do?
- curse of dimensionality -- discussion from LSE paper, and from Warwick paper;
- Warwick discussion on trees
- Friedman's role in trees
- the local vs global structure discussion - Hastie 19-20 onwards
- generative vs disciminative models
- situated all three algorithms by reference to adjacent work in humanities -- the trace/mark in deconstruction for handwriting recognition -- neural nets; the assemblage -- smooth space for svm; decision tree-random forest
- implement a neural network by going through Ng lectures or Hinton
- implement a svm - using Ng?
- add in some material from Flach's review of SVM
- add in references and examples from Shaw+Christiani textbook

## from proposal

:  regularisation - dimensional reduction, dimensional explosion -- infinite dimensional spaces; recommender engine - svd as well; ebay; hunch.com

For the last decade, the best-performing 'off-the-shelf' machine learning algorithm has been a technique known broadly as 'support vector machines' (SVM; see [@vapnik_nature_1999]). The chapter examines the architecture of this widely used algorithm both against the background of a spectrum of other statistical machine learning techniques, and more importantly, in terms of the *forms of movement* it brings to data practice. The key focus in this discussion is the dimensionality of data, and how dimensionality is managed in machine learning.  While curves and functions, as discussed the previous chapter, engender senses of change and movement, the advent of increasingly extended and particularly 'wide' datasets (many variables) implies models that embrace high-dimensional abstract spaces. Since the 1950s, scientists  have been aware of the 'curse of dimensionality' [@bellman_adaptive_1961], which arises when the dimensions of the data increase. Algorithms such as SVM, and implicitly other highly successful ML algorithms such as neural networks, manage this dimensionality very differently to the regression models that have been the mainstay of statistical modelling for a century. Rather than trying to reduce the dimensionality of the model to a line, plane or hyperplane that best fits the datasets, SVM expands the dimensionality  of the model massively, sometimes infinitely.


## overview

### recap and intro

- recap of vector space, function and the sheer proliferation of algorithms: some basic intuitions - -cut a space; embed the space in a higher dimensional context; 
- return to vector space as the guiding model -- both critical of this -- it linearises but is tricked out in various ways
- pattern discovery -- pathetic or worthwhile?

### decision trees

- why decision trees matter
- how decision trees were renovated
- how decision trees multiplied -- across fields; amongst themselves -- weak learners

### neural networks

- the perceptron reconceived
- neuralisation as the lure of learning

### svms


- recapitulating LDA
- the high dimensionality

### main arguments

- is there any possibility of an affirmative relationship to machine learning? Under what conditions? -- return to the ones I set out in ch1: Rabinow, Whitehead, Wilson, etc. Now want to ground those in some particular techniques that cut/include the world in different ways
- so many techniques to choose from: can only choose something whose specificity itself configures the literature, the field of practice, the knowledge economy in its own ways. 
    - choosing 3 techniques that include many other techniques in them somehow
        - random forests include many decision trees - 60-70s
        - neural networks include many logistic regressions and perceptrons - 50s
        - svms include many different dimensions -- basis functions + inner product (avoiding calculating too much); also Fisher's LDA - 30s
- see that including as countenancing alternatives -- and hence flashes of mentality into algorithms
- That is, to take the SVM  or NN or the Decision Tree seriously is already to understand the world in a particular way; each of them are monadologically potent; they express a world. 
- What we can do with this grip on the world? The idea of relaying it -- pursuing motion through experiments with forms of movement through scale and subjectivity
	- implementation as experiment in forms of movement -- the inner product, 
- How do they express/contain/grip the world?
	- critical argument: incredibly rigid approach in some ways to flux and change; what do we do with that rigidity?
	- extrinsic vs intrinsic structure: link to Whitehead can also use the shapeofdata stuff; -- key point -- how the vector space is reshaped; or not. Or the extraordinary efforts to get the vector space to accommodate differences
	- classification as the key problem: linear separability vs non-linear separability; strict splits vs shades of difference
	- making things linear in high dim: good or bad?  15 dim patterns 
    -  **key point**: it is possible to fit all the data perfectly, but suffer the consequences of generalization; or it is possible to identify the problematic boundary cases and focus on those. This is what svms do. But does it avoid overfitting? If random forests correct decisiont trees through randomisation, what is the trick in svm? And how does it deal with infinite dimensionality? 
- 


### quotes to use: theory

> The process that I am currently engaged in and seeking to name  ... concerns the emergence of form as a process, includes in an essential manner claims to say or see something true. The process that concerns me is the one in which such "knowledge-things" are being assembled 85 Rabinow

>it follows that if one's object is an anthropological account of a problematization, then one's informants will differ from each other. The challenge lies in finding an experiential and experimental site that would provide a contemporary instance. Rabinow, 87

>USED: I advocate pursuing in our thought and writing something like the motion, through different scales and different subject positions. ... Such movement is easy to initiate and hard to master. Yet I firmly believe that in the actual conjuncture of things, it is a paramount challenge for philosophy and the human sciences to experiment with forms that will be, if not fully adequate to, at least cognizant of, the need for such movement through scale and subjectivity. Rabinow, 135-6.
>
>Perhaps our knowledge is distorted unless we can comprehend its essential connection with happenings which involve spatial relationships of fifteen dimensions. W, MoT, 78
>
>The sharp-cut scientific classifications are essential for scientific method. But they are dangerous for philosophy. Such classification hides the truth that the different modes of natural existence shade off into each other. W, MoT, 215
>
>
>notion of pattern involves the concept of different modes of togetherness MoT, 195-6
>
>Thus beyond all questions of quantity, there lie questions of pattern, which are essential for the understanding of nature. Apart from a presupposed pattern, quantity determines nothing. Indeed quantity itself is nothing other than analogy of functions within analogous patterns W, MoT, 195
>
>My unity -- which is Descartes' "I am" --is my process of shaping this welter of material into a consistent pattern of feelings.  W, MoT, 228
>
>new function estimation methods have been created where a high dimensionality of the unknown function does not always require a large number of observations in order to obtain a good estimate. The new methods control generalization using capacity factors that do not necessarily depend on the dimensionality of the space vii Vapnik
>
>The kernel trick is another commonly used technique to solve linearly inseparably problems. This issue is to define an appropriate kernel function based on the _inner product_ between the given data, as a nonlinear transformation of data from the input space to a feature space with higher (even infinite) dimension in order to make the problems linearly separable. The underlying justification can be found in _Cover's theorem_ on the separability of patterns; that is, a complex pattern classification problem case in a high-dimensional space is _more likely_ to be linearly separable than in a low dimensional space. Wu, 42
>

>In two-class data, separability by a hyperplane does not often occur. However,
let us increase the dimensionality by adding as additional predictor variables
all quadratic monomials in the original predictor variables; that is, all
terms of the form xm1 xm2 . A hyperplane in the original variables plus
quadratic monomials in the original variables is a more complex creature. The
possibility of separa- tion is greater. If no separation occurs, add cubic
monomials as input features. If there are originally 30 predictor variables,
then there are about 40,000 features if monomials up to the fourth degree are
added. [@breiman_statistical_2001, 209]


>To repeat the precarious political pragmatic hope I presented, it is only if we become able, as philosophers, to put scientific achievements on the same plane of immanence together with other diverging conventions, each with its demanding definition of what matters, that we can stop poisoning this hope, that we can share, instead, the pragmatic concern for the itinerant process of creation of new ‘‘it works’’ as they mark the process of empowerment of new minorities, with new actively diverging ‘‘habits’’ that must be celebrated each time as something new entering the world and indeed as modifying it. Stengers, 2005, 162
>

### main examples/illustrations & materials to draw on 

support vector machine -- the Russian connection; the text classification projects

-- Ng's lectures  -- go through notes on this
-- Vapknik
-- the trajectories of neural networks and support vector machines in the literature

neural  network -- the McCulloch-Pitts connection -- heather what's her name on cat recognition; -- the autonomous vehicles;  my camera and its face recognition; kittydar

decision tree - random forest

## Introduction

> The complexity of a data set increases rapidly with increasing dimensionality [@breiman_cart_1984, 8]

> The first problem facing you is the bewildering variety of learning algorithms available. Which one to use? There are literally thousands available, and hundreds more are published each year [@domingos_few_2012, 1]

Under what conditions would it be possible to have an affirmative relationship to machine learning? This seems like a difficult learning problem in its own right. First of all,  the problem in answering this question is that there are so many techniques to choose from, and each of these techniques includes and  cuts the world in different ways. We have already seen that the list of techniques and the domain of their application is vast by any standards. 

```{r mlit1, echo=FALSE, cache=TRUE, message=FALSE, warning=FALSE, comment=NA, size='smallsize', results='asis' } 

    library(xtable)
    ml_dir = '../ml_lit/data/machine_learning_WOS'
    files <- dir(ml_dir,full.names=TRUE, pattern='savedrecs.*')
    recs <-lapply(files, read.csv, sep='\t', header=TRUE, as.is=TRUE, quote='', row.names=NULL)  
    ml_df <-do.call( rbind, recs )
    colnames(ml_df)[1:52] <- colnames(ml_df)[2:53]
    colnames(ml_df)[1] <-'PT'
    ml_df = ml_df[order(ml_df$TC, decreasing=TRUE),]
    print(xtable(head(ml_df[,c('TI', 'TC')])))

```

The machine learning literature itself has a sprawling, fluxing dimensionality, not easily captured by search terms or disciplines. The academic papers themselves are daunting in their bulk and variety, before we even try to move into the much more crowded and heavily trafficked domains where machine learning is practiced.  This literature itself, viewed in machine learning terms, comprises a high-dimensional vector space, whose features and attributes unstably move around as the techniques find new applications, as computer scientists, engineers, statisticians and others work on reshaping them, sometimes concertedly, sometimes independently and at odds with each other.  Viewed as a bundle of divergent, tangled trajectories in a high-dimensional social-material space, machine learning (or data-mining) can be described, sorted, and classified  in different ways. The immediate question is: what form of movement, from trajectories through the forest of practices associated with machine learning would allow us to inhabit the space of machine learning? What kinds of scales and subject positions would we need to move through in order to do that? A less immediate but no less important question is: in the name of what or whom would we affirm machine learning? This question is not going to be answered easily, but it also involves many choices about where to move and how fast to move. 

As I have emphasised previously, the form of movement through machine learning I'm experimenting with here is recursive or loopy. That is, rather than describing machine learning from the outside, or participating in it as an observer (participant observation, or even observant participation), I explore some possibilities of moving through machine learning by learning machine learning.  And as  discussed earlier, here the term 'learning' is overloaded with multiple meanings and practices. But the motivation is similar to what the anthropologist Paul Rabinow advocates: 'pursuing in our thought and writing something like motion, through different scales and different subject positions. ... Such movement is easy to initiate and hard to master. Yet I firmly believe that in the actual conjuncture of things, it is a paramount challenge for philosophy and the human sciences to experiment with forms that will be, if not fully adequate to, at least cognizant of, the need for such movement through scale and subjectivity' [@rabinow_anthropos_2003, 135-6]. Most of my learning of machine learning took place through textbooks and how-to materials, scientific articles, databases of scientific literature and sample datasets, online tutorials, Wikipedia pages, software documentation, read and writing many lines of `R` or `python` code. As Rabinow suggests, it is easy to start moving through machine learning, but hard to control that movement. I have found myself careening through websites, software manuals, YouTube lectures on machine learning, short intensive courses on data mining, news reports, APIs, code repositories and various code fragments.  Much of this movement has been saccadic  and aleatory rather than purposive or Dao-like, and only in writing now, in attempting to connect code, literature, people and events, I attempt to steer this movement a little more purposively. In the course of moving backwards and forwards between research articles, textbooks, datasets and code, it is sometimes to possible to find amidst the many contingencies and specificities, some general forms of movement. 

## Movement and stasis in data

Let us return to basic problem of data. Imagine we have a dataset, with many variables and with many components.  Although we may know where the data came from, and what it refers to, we don't have any firm ideas about the patterns or structures in it.  We can view the dataset to a certain extent by plotting it. 

```{r data_set, echo=FALSE, cache=TRUE, message=FALSE, warning=FALSE, comment=NA, results='asis', engine='python' } 

import random
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import numpy as np


size = 1000
x = np.random.uniform(0,10, size)
y = x+ np.random.normal(np.mean(x), 5.0, size)
z = np.random.randint(20,80, size)
class1 = np.random.randint(0,2, size)
class2 = np.random.randint(1,4, size)

plt.figure()
p1 = plt.subplot(121)
plt.scatter(x[class1==0],y[class1==0],s=0.5*z[class1==0], marker='o', 
    c = class2[class1==0], cmap = cm.Set1, hold='on', label='A')
plt.scatter(x[class1==1],y[class1==1],s=0.5*z[class1==1], marker='*', 
    c = class2[class1==1], cmap = cm.Set1, label='B')
plt.title('Synthetic data')
plt.legend()

import pandas as pd
titanic = pd.DataFrame.from_csv('data/titanic_train.csv')
p2 = plt.subplot(122)
male = titanic.ix[titanic.Sex == 'male']
female = titanic.ix[titanic.Sex=='female']

plt.scatter(male.Age, male.Fare, c=male.Survived, cmap = cm.Set1,  s=10+10*male.SibSp, marker='*', hold='on', label='male')
plt.scatter(female.Age, female.Fare, c=female.Survived, cmap = cm.Set1,  s=10+10*female.SibSp,  marker='o', label='female' )
plt.title('Survivors of the \it{Titanic}')
plt.xlabel('Age')
plt.ylabel('Fare')
plt.legend()

plt.savefig('figure/twin_data.png', dpi=400)
print('![Data shapes](figure/twin_data.png)')
print('![Iris decision tree](figure/tree_graph.png)')

```

These two plots come from somewhat different origins. Typically, expositions of machine learning use two kinds of datasets. Some data is generated by computers for the purposes of showing how a particular technique works. That is the case for the first dataset, shown on the left of the figure. The 1000 somewhat random points have no obvious structure, although, as per the basic understanding of machine learning as 'function estimation' (see the previous chapter), there might be functions generating the points. The dataset shows  only five dimensions (conveyed by `x`, `y`, colour, shape and size graphics).   Every point can be classified in more than one way (for instance, by shape or by colour, which might in turn refer to some other matter of fact).   At other times,  datasets come from the world, or more likely, from some curated collection of datasets that left the  wider world behind quite a while ago [^1].  We have seen these datasets already in discussing house prices (Boston, New York, San Francisco), the _iris_ dataset, the Enron email dataset,  and there are others relating to handwritten digits or prostate cancer that appear often in textbooks, tutorials, manuals and research publications. The plot on the right shows some data about passengers of the _Titanic_. The fare they paid, their age, their sex, the number of family they were travelling with, and whether they survived or not are shown here. Again, there is no obvious structure here. Women and children seem to have a better change of surviving, but there is no obvious pattern in survival. In both datasets, it seems that drawing straight lines through the data, at least the data as it is plotted here, is unlikely to help in classifying things. There many be some boundaries or relevant differences between different parts of the data, but those boundaries are not in any obvious way linear, or even approximately linear. These kinds of situations have long abounded in science, in statistics and in any place where many measurement or observations are made. The problem of _pattern recognition_, a now slightly less popular term for many of the techniques now called machine learning, was concerned precisely to find patterns in data that lacked any apparent linear structure. 

The two datasets represent extreme positions that have long been recognised in machine learning literature. Writing in 1966 at Stanford, the information theorists Thomas .M. Cover and Peter E. Hart  describe 'two extremes of knowledge which the statistician may possess':  'complete statistical knowledge of the underlying joint distribution of the observations'  or 'no knowledge of the underlying distribution except that which can be inferred from samples' [@cover_nearest_1967, 21]. (Their paper on 'Nearest Neighbour Pattern Classification' is still widely cited and constitutes a classic in the field.) As it turns out, I do have knowledge of the underlying statistical distribution for the synthetic dataset, but no knowledge for the _Titanic_ dataset (as we will see in the next chapter, where the _Titanic_ dataset plays an active role). In between these two extremes, lie a range of datasets whose underlying distributions might be partially known. (The _iris_ dataset discussed below is perhaps one instance more in the middle.) While the differences  between knowing the functions that generated the data and estimating the functions that could have generated  it is said to be extreme, in practice it doesn't matter so much. Nearly all machine learning techniques assume incomplete knowledge, and sometimes assume no knowledge (as for instance, in  'unsupervised' techniques that do various kinds of clustering). 

[^1]: Many of the most widely used machine learning datasets can be found at the [UC Irvine Machine Learning Repository](http://archive.ics.uci.edu/ml/). The UCI repository itself is one of the most cited references in the machine learning literature.

Both the main techniques I discuss here -- decision trees and support vector machines -- assume that patterns are non-linear, and that the differences between things are complicated. Introducing the important and indeed perhaps transformative potential of support vector machine, Hastie, Tibshirani and Friedman write, for instance:  'the _support vector machine_ ... produces nonlinear boundaries by constructing a linear boundary in a large transformed version of the feature space' [@hastie_elements_2009, 417]. We could ask: can we do something similar  in moving through the forest of overlapping techniques associated with machine learning, pattern recognition, data-mining, or their slightly updated incarnations in 'data [intensive] science' or 'data analytics'?  In other words, can analysis of such techniques yield critical and philosophically evocative constructs that help make sense of what is happening to data today?

## The movements: statistical, imitative, infinitist

```{r ml_top_cites, echo=TRUE, cache=TRUE, message=FALSE, warning=FALSE, comment=NA , engine='python'} 

import ml_lit_anal as ml
import google_scholar_parser as gs
import pandas as pd
import numpy as np
import collections

df = ml.load_records('../ml_lit/data/machine_learning_WOS/')
df = ml.clean_topics(df)
print('There are %s records in the dataset'%df.shape[0])t
all_refs = [ref for refs in df.cited_refs for ref in refs]
ref_collection = collections.Counter(all_refs)
print(ref_collection.most_common(n=20))
```

The machine learning research literature attests to the proliferation of techniques and practices. The machine learning literature is enormously but helpful in deciding which direction to move. It bristles with references to papers in statistics, computer science, mathematics, artificial intelligence and a swathe of related scientific fields. In the background stand substantial bodies of knowledge and practice coming from the social sciences, insurance and actuarial practice, and marketing research. A very rough citation analysis of the research literature indicates that  the top 20 most cited publications in the field have focused on decision trees (Quinlan, Breiman), on support vector machines (Vapnik, Christiani, Cortes, Chang),  machine learning pedagogy (Mitchell, an early textbook written by a computer scientist; Witten, a textbook and software package on data mining using Java; Duda, a textbook on pattern recognition), a tutorial on an error control techique (ROC - Receiver Operating Characteristics, first developed by the US military during WWII) and somewhat lower, the popular machine learning technique of neural networks (Bishop). Across these variations, it is possible to discern some different forms of movement, or put simply, movements in machine learning. Briefly and perhaps too crudely summarised, they might be termed a _statistical_ movement, an _imitative_ movement, and an _infinitist_ movement. 

[ADD HERE: stuff from python notebook about topics and how they are organised ... including graph?]

The descriptive challenge entailed in tracking these movements was  figured more than a decade ago by Geoffrey Bowker and Susan Leigh Star in their work on classification systems. They wrote then:

> Imagine you are walking through a forest of interarticulated branches. Some are covered with ice or snow, and the suns melts their touching tips to reveal space between. Some are so thickly brambled they seem solid; others are oddly angular in nature, like esplanaded trees.  Some of the trees are wild, some have been cultivated ... Helicopters flying overhead can quickly tell your many types of each, even each leaf, there are in the world, but they cannot yet give you a guidebook for bird-watching or forestry conservation. There is a lot of underbrush and a complex ecology of soil bacteria, flora and fauna.  ... Now imagine that the forest is a huge information space and each of the trees and bushes are classification systems.  ... Your job is to describe this forest. [@bowker_sorting_1999,31-32]

Bowker and Star refer here to a variety of standardised classification systems running across sciences, institutions, industries and geographies. Many of these classifications have extended genealogies running back more than a century or so through paper-record based systems. The classification systems exemplified in machine learning are in some ways much less diverse than Bowker and Star's examples in that they do not directly index a plurality of practices. Indeed, machine learning in many cases seeks to reduce the plurality of practices to a set of algorithmic processes that can be monitored and controlled directly.  As we will see, a concern with the _generalization of classification_ pervades the field. Nevertheless, a clear contrast between the Bowker and Star's challenge and the problems of machine learning comes through: while much, perhaps most,  machine learning practice concerns long-standing problems of classification, the classifying done in machine learning has little or no paper-based precedent. Many of the best-known and most widely used contemporary techniques -- logistic regression, neural networks, decision trees, random forests, support vector machines and a variety of clustering techniques -- do focus on classification problems, but classify in ways that lie a long way from the sorting and ordering practices found in preceding classification systems. 

As it turns out, at the very time Bowker and Star were writing about the interarticulated forest of classification systems, the technique of RandomForests (TM) was being developed as a way of navigating huge information spaces. Statisticians such as Leo Breiman at UCLA were assembling decision trees (a technique I discuss below) into forests that could classify [@breiman_random_2001].  In the machine learning literature,  the random forest paper is the most highly cited reference [@breiman_random_2001]. According to Thomson Scientific Web of Science/ISI, this paper has been cited  `r ml_df$TC[1]` times. Like two other key machine learning techniques -- neural networks in the 1980s; support vector machines in the late 1990s --  random forests provided different ways of moving through the thicket of possible connections, associations, features and relations occasioned by digital data, especially as online data sets were becoming available.  This is not to say the machine learning techniques are absolutely unprecedented. On the contrary, each of these techniques of random forests, neural networks and support vector machine, as I will discuss below, took an existing predictive or classificatory technique or mechanism and re-configured it in order to deal with the problems of a disorientating profusion of  possible classifications. With lesser and greater degrees of success, they brought together different scales of movement, and different ways of including the world. 

So in a way, machine learning has been taking on the job that Bowker and Star envisaged: 'imagine you are walking in a forest -- describe this forest.' But the forest we are moving in here is a forest of machine learning classifiers, mainly taking root in the  scientific-technical literature and associated software implementations.  The basic intuitions underlying  machine learning classification are not hard to grasp. We have already seen a few versions of it. Logistic regression, the technique discussed in the previous chapter and pervasively used in biomedical sciences, is a mainstay of classification techniques.  The techniques of decision trees, random forests, neural networks and support vector machines I will discuss here display many commonalities in their treatment of data.  They all  attempt to find ways of moving through data, and dealing with problems of deciding what groups, classes or sets things belong to, without having to know too much about  the world that data indexes. At the same time, or strictly speaking, slightly afterwards, these techniques themselves move through the world. Their movement is never purely abstract, as if they only inhabited a mathematical forest, although it possesses a certain texture or specificity. As with all functions, indelible residues of indexicality entangle machine learning technique with matters of fact. I like the way the biostatisticians  James Malley, Karen Malley and Sinisa Pajevic describe machine learning: 'if the data has any signal at all then most machines will detect it' but 'we freely admit that many machines studied in this text are somewhat mysterious, though powerful engines' [@malley_statistical_2011, 257]. As we will see, the ways in which machine learning methods move through data detecting signals are intensively theorised yet at the same time not well understood. 


## Growing trees in irises

> Mastering the details of tree growth and management is an excellent way to understand the activities of learning machine generally [@malley_statistical_2011, 118].

```{r aid, echo=FALSE, cache=TRUE, message=FALSE, warning=FALSE, comment=NA , fig.cap='Early uses of the Automatic Interaction Detector'} 
    library(xtable)
    aid_df = '../ml_lit/data/morgan_sonquist_WOS'
    files <- dir(aid_df,full.names=TRUE)
    recs <-lapply(files, read.csv, sep='\t', header=TRUE, as.is=TRUE, quote='', row.names=NULL)  
    aid_df <-do.call( rbind, recs )
    colnames(aid_df)[1:52] <- colnames(aid_df)[2:53]
    colnames(aid_df)[1] <-'PT'
    aid_df$TI = tolower(aid_df$TI)
    aid_df = aid_df[order(aid_df$PY, decreasing=FALSE),]
    print(xtable(head(aid_df[,c('TI', 'PY' ,'TC')],10)))
```

Work on classification and regression techniques using decision tree algorithms goes back to the  early 1960s when social scientists James Morgan and John Sonquist at the University of Michigan's Institute for Social Research were attempting to analyse increasingly large social survey datasets [@morgan_problems_1963].  As Dan Steinberg describes in his brief history of decision trees [@steinberg_cart_2009, 180], the  'automatic interaction detector' (AID) as it was known, sought to automate the practice of data analysts looking for interactions between different variables. The variety and sheer optimism of subsequent applications of these prototype decision tree techniques  is striking.  In the 1960s and 1970s, papers that drew on the AID paper or use AID techniques can be found, as the table shows, in education, politics, economics, population control, advertising, mass media and family planning. 

But a decade after initial work, the AID was the object of trenchant criticism by statisticians and others. Writing in the 1970s, statisticians in the bebavioural sciences such as Hillel Einhorn at the University of Chicago castigated the use of such techniques.   The criticisms stemmed partly from  a general distrust of 'purely empirical methods':

> The purely empirical approach is particularly dangerous in an age when computers and packaged programs are readily available, since there is temptation to substitute immediate empirical analysis for more analytic thought and theory building. It is also probably too much to hope that a majority of researchers will take the time to find out how and why a particular program works. The chief interest will continue to be in the output-the results-with as little delay as possible [@Einhorn_alchemy_1972, 368]

Einhorn discusses AID alongside other  techniques such as factor analysis and multi-dimensional scaling (both still widely used) before concluding 'it should be clear that proceeding without a theory and with powerful data analytic techniques can lead to large numbers of Type I errors' [@einhorn_alchemy_1972, 378]. His specific objections to AID are  particularly focused on the problematic power of the technique: 'it may make sense out of "noise"' (369). Consequently, researchers easily misuse the technique: they 'overfit' the data, and do not pay enough attention to issues of validation (369-370). Most of these criticisms can be seen as expressing conventional statistical reservations. Similarly the British marketing researcher Peter Doyle, criticising the use of AID in assessing store performance and site selection by operation researchers, complained that searching for patterns in data using small data sets was bound to lead to spurious results and the decision trees, although intuitively appealing (that is, they could be easily interpreted), were afflicted with arbitrariness: 'a second variable may be almost as discriminating as the one chosen, but if the program is made to split on this, quite a different tree occurs' [@doyle_use_1973, 465-466].  These objections and resistances to early decision trees echo today in discussions around pattern recognition, knowledge discovery and data-mining in science and commerce.    The problem of what computers do to the analysis of empirical data is long-standing. 

As Einhorn expected, it was too much to hope that a majority of researchers would take time to investigate how a particular program works. Some researchers however did take time, years in fact, to investigate how decision trees work. As a result, writing in 2008, Hastie, Tibshirani and Friedman, who have excellent academic statistical credentials by any standards, could happily recommend decision trees as the best off-the-shelf classifier:  'Of all the well-known learning methods, decision trees comes closest to meeting the requirements for serving as an off-the-shelf procedure for data-mining' [@hastie_elements_2009, 352]. In 2013, Salford Systems, the purveyors of the leading contemporary commercial decision tree software, CART, claim:

 > CART is the ultimate classification tree that has revolutionized the entire field of advanced analytics and inaugurated the current era of data mining. CART, which is continually being improved, is one of the most important tools in modern data mining. Others have tried to copy CART but no one has succeeded as evidenced by unmatched accuracy, performance, feature set, built-in automation and ease of use. [Salford Systems](http://www.salford-systems.com/products/cart)

What happened between 1973 and 2008?  The happy plight of decision trees emblematises the emerging, evolving flow of techniques associated with machine learning.  Decision trees somehow travelled from the statistically murky waters of the social sciences and business schools in the early 1970s to inaugurate the 'current era of datamining' (which the scientific literature suggests starts in the early 1990s). As the earlier citation from U.S. National Institutes of Health biostatisticians Malley, Malley and Pajevic indicates, decision trees now enjoy high regard even in biomedical research where statistical rigour is highly encouraged for life and death reasons. 

### 1984: Breiman, Friedman, Olshen and Stone's _Classification and Regression Trees (CART)_

As it turns out, working at the US Department of Energy's Stanford Linear Accelerator during the late 1970s, Jerome Friedman, the third author of Hastie, Tibshirani  and Friedman, was  instrumental in rescuing  decision trees from ignominy of unstability they had entered in the late  1960s. I am not writing a history of machine learning techniques, so I will not trace in any detail the reorganisation and statisticial retrofitting of the decision tree. It was not a single or focused effort. During the 1980s, statisticians such  as Friedman and Leo Breiman renovated the decision tree as a statistical tool at the same time as  computer scientists such as  Ross Quinlan in Sydney were re-implementing decision trees as rule-based induction technique for artificial intelligence [@quinlan_induction_1986]. Quinlan's papers  and book on versions of the decision tree (`ID3` and `c4.5`) are both amongst the top ten the most highly cited references in the machine literature itself. Google Scholar reports over 20,00 citations of the Quinlan's book _C4.5: Programs for Machine Learning_ [@quinlan_c4._1993]. This uneasy parallel effort between computer science and statistics  still characterises machine learning today. Both statisticians and computer scientists  do and use the same techniques, but often with slightly different inflections, formalizations and nomenclature.  Here I want to introduce only those steps in the renovation of the technique that helped consolidate decision trees as 'best off-the-shelf classifier,' such that today the standard  `R`package `rpart` constructs decision trees at a moment's notice and `C4.5` is voted the top data mining algorithm [@wu_top_2008]. 

As usual, I treat the implementation of techniques in R as offering one path into  their wider practice, a path that perhaps favours the statistical side of that practice, but that nevertheless has certain forensic virtues not offered by commercial or closed-source software.  In this case, the name of the `R` package itself attests to something: `rpart` is a contraction of 'recursive partitioning' and this term generally describes how the decision tree algorithm works.  The term 'decision tree,' although still widely used in the research literature and elsewhere was replaced by 'classification and regression tree' during the late 1970s and 1980s work on decision tree. The terms 'classification and regression tree' is sometimes contracted to 'CART,' and that term strictly speaking refers to a computer program described in [@breiman_cart_1984]. It is also a registered trademark of Salford Systems, the software company mentioned above, who sell the leading commercial implementation of classification and regression trees. Hence, the `R` package `rpart` cannot call itself the more obvious name `cart, ` and instead invokes the algorithmic process it relies on: 'recursive partitioning.'

To get a sense of what happened between the 1970s and 1980s process leading up to `CART` and `C4.5`, we can again load  R.A. Fisher's _iris_ dataset, which contains measurements made in the 1930s of petal and sepal lengths of _iris virginica, iris setosa_ and _iris versicolor_. I should point out that this is a very small dataset. It is definitely a pre-computational miniature, but that diminutive character makes it into a useful illustration. While the _iris_ dataset is quite small, it supports a rhizomatic ecosystem of examples scattered across the machine learning literature.    The usual framing of the classification problem is how to decide whether a given iris blossom is of the species _virginica_, _setosa_ or _versicolor_.   These irises don't grow in forests -- they are more often found in riverbanks and meadows --  but they do offer a variety of illustrations of how machine learning classifiers are brought to bear on classification problems. Here the classification problem is taxonomic - the  iris genus has various sub-genera, and sections within the sub-genera. _Setosa, _virginica_ and _versicolor_ all belong to the sub-genus _Limniris_. This botanical context is  routinely ignored in  machine learning applications. In machine learning textbooks and tutorials, iris typically would be used to demonstrate how cleanly a classifier can separate the different kinds of irises. 


```{r iris_tree, echo=TRUE, cache=TRUE, message=FALSE, warning=FALSE, comment=NA, size='smallsize', results='asis' } 

    data(iris)

    library(rpart)
    head(iris)

    iris_tree =rpart(Species ~ ., iris)
```

The code shown here loads the _iris_ data (the dataset  is routinely installed with many data analysis tools), loads the `R` decision tree library, prints a few lines of the iris dataset and builds a decision to classify the irises by species.  What has happened to the iris data in this decision tree? The `R` code that invokes the decision tree model is so brief `iris_tree =rpart(Species ~ ., iris)` that we can't tell much about how the data has been 'recursively partitioned.' We know that the _iris_ has `r nrow(iris)` rows, and that there are equal numbers of the three iris varieties.  From the standpoint of CART, and in particular the landmark _Classification and Regression Trees_ monograph [@breiman_cart_1984]  written by four statisticians working in California, the  rows of _iris_ are 'measurement vectors':

> Define the measurements $(x_1, x_2, ...)$ made on a case as the _measurement vector_ $\mathbf{x}$ corresponding to the case. [@breiman_cart_1984, 3]

The _iris_ dataset, small though it is, defines a larger space that Leo Breiman working  and co-authors called a 'measurement space' ('Take the _measurement space_ $\mathcal{X}$ to be defined as containing all possible measurement vectors' [@breiman_cart_1984, 3]). In beginning to re-implement decision trees as classification trees, Breiman first address issues of data dimensionality. This talk of vectors and space is pervasive in the machine learning literature. What they call the measurement space is more often today called the 'vector space', but otherwise their characterisation of the difficulties of navigating that space, and how CART occupies that space remain more or less current.  In order to get into that space, and in order for us to grasp how _iris_ has been classified through the one liner `rpart(Species _., iris)`, Breiman and Friedman orchestrate a  whole series of formalizations that again, I won't follow in any great detail, but simply excerpt a few salient points.  These formalizations allow trees to be constructed algorithmically, and in that respect, directly promote tree growth. 

First of all,  all construction and use of  the decision tree  are renovated in terms of functions, sets, vector spaces and cost functions. (We have seen this process before in the previous chapter in the case study of logistic regression and gradient algorithms; refer to that for an account of functions in practice.)  For instance, rather simply invoking the notion of a classifier, the CART monograph defines a classifier in terms of a function: 

> A classifier or classification rule is a function $d(\mathbf{x})$ defined on $\mathcal{X}$ so that for every $\mathbf{x}$, $d(\mathbf{x})$ is equal to one of the numbers $1, 2, ..., J$. [@breiman_cart_1984, 4]


 The definition of the classifier as a function depends on the existence of a vector space $\mathcal{X}$, a set of measurement, feature or predictor vectors  $\mathbf{x}$ and a set of responses  $1, 2, ..., J$. Second, classification is understood in terms of a series of binary splits that comprise the tree structure. The problem here is that many splits are possible. 

> The first problem in tree construction is how to use $\mathcal{L}$ to determine the binary splits of $\mathcal{X}$ into smaller pieces. The fundamental idea is to select each split of a subset so that the data in each of the descendant subsets are "purer" than the data in the parent subset [@breiman_cart_1984, 23].

Tree construction hinges on the notion of purity or more precisely 'node impurity', a function that measures how data of labelled as belonging to different classes are mixed together at a given branch or node in a decision tree: 'that is, the node impurity is largest when all classes are equally mixed together in it, and smallest when the node contains only one class' [@breiman_cart_1984, 24]. As Malley and co-authors note, 'the collection of purity measures is still a subject of research' [@malley_statistical_2011, 123], but Breiman, Friedman, Olshen and Stone promoted a particular form of impurity measure known as 'Gini index of diversity' [@breiman_cart_1984, 38].  Like the cost function used in optimising linear and logistic regression models, the measures of node impurity allow the process of tree construction to be understood as a kind of movement through space. Whereas in gradient descent, the intuition was 'always go down to the valley as quickly as possible', here the intuition is more like: ' split things in ways that minimize mixing'. Good splits decrease the level of impurity in the tree. In an ideal tree with maximum purity, each terminal node -- the nodes at the base of the tree -- would contain a single class. 

The results of the application of measures of node impurity can be seen below in two plots. 

```{r iris_tree_plot, echo=FALSE,  fig.cap ='Decision tree on _iris_ dataset', cache=TRUE, message=FALSE, warning=FALSE, comment=NA, results='asis' } 

    par(mfrow = c(1,2), xpd=NA)
    plot(iris_tree, main = 'tree recursive partitioning of iris')
    text(iris_tree, cex=0.8, use.n=TRUE)
    table(iris$Species) # is data.frame with 'Species' factor
     iS <- iris$Species == "setosa"
     iV <- iris$Species == "versicolor"
     op <- par(bg = "bisque")
     matplot(c(1, 8), c(0, 4.5), type =  "n", xlab = "Length", ylab = "Width",
             main = "Petal and Sepal Dimensions in Iris Blossoms")
     matpoints(iris[iS,c(1,3)], iris[iS,c(2,4)], pch = "sS", col = c(2,4))
     matpoints(iris[iV,c(1,3)], iris[iV,c(2,4)], pch = "vV", col = c(2,4))
     legend(1, 4, c("    Setosa Petals", "    Setosa Sepals",
                    "Versicolor Petals", "Versicolor Sepals"),
            pch = "sSvV", col = rep(c(2,4), 2))
```

The plot on the left shows the decision tree and the plot on the right shows just _setosa_ and _versicolor_  plotted by petal and sepal widths and lengths.  As the plot on the right shows, most of the measurements are well clustered. Only the _setosa_ petal lengths and widths seem to vary widely. All the other measurements are tightly bunched. This means that the decision tree shown on the left has little trouble classifying the irises. Decision trees are read from the top down, left to right. The top level of this tree can be read, for instance, as saying, if the length of petal is less 2.45, then the iris is _setosa_. Hastie, Tibshirani and Friedman  suggest that 'a key advantage of the recursive binary tree is its interpretability. The feature space partition is fully described a by single tree.  ... This representation is popular among medical scientists, perhaps because it mimics the way a doctor thinks.  The tree stratifies the population into strata of high and low outcome, on the basis of patient characteristics' [@hastie_elements_2009, 306-7]. I would differ from them on this point.  Decision trees do indeed have a rich  medical, as well  commercial and industrial history of use. And yes, decision trees and their later variations (such  as`C4.5`, the 'top' data-mining algorithm according to a survey of data miners in 2009 [@wu_top_2008] was developing during the 1980s in response to Friedman's work on decision trees) are often presented as easy to use because they are 'not unlike the serious of troubleshooting questions you might find in your car's manual to help determine what could be wrong with the vehicle' [@wu_top_2008,2]. (But who actually reads car manuals?) While that scenario is unlikely today, especially as Google sends autonomous-driving cars out onto the roads of California undoubtedly controlled by a variety of classifiers such as decision trees, neural networks and support vector machines, the recursive partitioning technique still has a great deal of traction in machine learning practice precisely because of its simplicity.

The problem with _iris_ is that the species actually ontically separate. The pattern of separation that the decision tree algorithm finds exists in the world for us too, except when, as happens, species of iris hybridise with each other. In many cases, things as Whitehead suggests, are not cleanly separable. Often there is some pattern of separation, perhaps in the form of overlapping clusters or clouds of points, but not enough to define a simple set of decision rules.  (As we will see that support vector machines, with their 'maximum margin hyperplanes,' take these overlaps as given, and build models focused on the overlaps.) How then does a decision tree decide how to split things? What counts as a good split has been a long standing topic of debate in the decision tree literature. Choosing where to cut: this is a key problem for classification or decision trees. As Malley, Malley and Pajevic observe, 'the challenge is to define _good_ when its clear that no obviously excellent split is easily available' [@malley_statistical_2011, 121].  The definition of 'good' that has emerged in the decision tree literature is centred on 'node purity.'

It is worthwhile looking at what actually happens to the data as  a decision tree is constructed in standard decision tree software such as `rpart` or its Python equivalents. 'Tree-based methods partition the feature space into a set of rectangles and then fit a simple model (like a constant) in each one. They are conceptually simple yet powerful' [@hastie_elements_2009, 305].  This specification is quite precise. The tree method  partitions data into _rectangles_, but the rectangles cannot overlap or in any way deviate alignment with the horizontal or vertical axes. The binary partitions produced are like housing plots of various sizes lined up within a block. As usual in  descriptions of machine learning techniques, the metaphors and analogies are two or three dimensional, but the practical implementations work in much higher dimensions. 

```{r "tree_decision_surface", echo=FALSE, cache=TRUE, message=FALSE, warning=FALSE, comment=NA,  results='asis', engine='python' } 

import numpy as np
import pylab as pl

from sklearn.datasets import load_iris
from sklearn.tree import DecisionTreeClassifier
    
n_classes = 3
plot_colors = "bry"
plot_step = 0.02

iris = load_iris()

for pairidx, pair in enumerate([[0, 1], [0, 2], [0, 3],
                                [1, 2], [1, 3], [2, 3]]):
    X = iris.data[:, pair]
    y = iris.target

    idx = np.arange(X.shape[0])
    np.random.seed(13)
    np.random.shuffle(idx)
    X = X[idx]
    y = y[idx]

    mean = X.mean(axis=0)
    std = X.std(axis=0)
    X = (X - mean) / std

    clf = DecisionTreeClassifier().fit(X, y)

    pl.subplot(2, 3, pairidx + 1)

    x_min, x_max = X[:, 0].min() - 1, X[:, 0].max() + 1
    y_min, y_max = X[:, 1].min() - 1, X[:, 1].max() + 1
    xx, yy = np.meshgrid(np.arange(x_min, x_max, plot_step),
                         np.arange(y_min, y_max, plot_step))

    Z = clf.predict(np.c_[xx.ravel(), yy.ravel()])
    Z = Z.reshape(xx.shape)
    cs = pl.contourf(xx, yy, Z, cmap=pl.cm.Paired)

    pl.xlabel(iris.feature_names[pair[0]])
    pl.ylabel(iris.feature_names[pair[1]])
    pl.axis("tight")

    for i, color in zip(range(n_classes), plot_colors):
        idx = np.where(y == i)
        pl.scatter(X[idx, 0], X[idx, 1], c=color, label=iris.target_names[i],
                   cmap=pl.cm.Paired)

    pl.axis("tight")

pl.suptitle("Decision surface of a decision tree using paired features")
pl.legend()
pl.savefig('figure/tree_graph.png')
print('![Iris decision tree](figure/tree_graph.png)')
```

In the example shown above, the different shadings of the rectangles indicate areas that the decision tree has classified in different species. While these decision surfaces look somewhat irregularly , they are all   combinations of rectangles.  The plots above, again, show 'decision surfaces' in two dimensions, but the dataset has at least five dimensions (petal width, petal length, sepal width, sepal length, species). The splitting of variables into pairs and then plotting them against each other is a way to put this decision surface in some perspective. As often happens in machine learning, it is not possible to see data in all its dimensionality. Instead, machine learning techniques often construct some perspective that allows the reshaping of the data to become visible in some part. 

What happens in decision trees to differences and in particular those differences that we regard as important enough to develop classifications for? Whitehead suggests that 'sharp-cut scientific classifications are essential for scientific method. But they are dangerous for philosophy. Such classification hides the truth that the different modes of natural existence shade off into each other' [@whitehead_modes_1956, 215]. Decision trees actually take this truth to heart. In higher dimensional feature spaces, many different classifications are possible and a huge number of different trees could be constructed for any given dataset. Even for the _iris_ dataset,  different implementations of the algorithm generate different results because of the way they optimise the tree they select.  Given that the aim is to generate a rule that best separates categories or classes of subjects, events or things of interest, how can decision tree techniques deal with this potential proliferation of rules?  In some ways, it seems that the decision tree researchers were reading actor-network theory as they developed the recursive partitioning algorithms. On the one hand, they are almost agnostic about differences in the world. As the biostatisticians Malley, Malley and Pajevic write in their account, 'no distributional assumptions or other statistical premises are made in decision trees concerning the features or the subjects' [@malley_statistical_2011, 20]. 'Wait,' readers of actor network theory might say, 'that sounds like the ontological pluralism of actor network theory, or William James or A.N. Whitehead.' Indeed, decision trees (and as we'll see, random forests) are emphatically agnostic about what differences matter in principle.  But their almost inexhaustible capacity to accommodate differences can make them unstable. 

## Cannot see the trees for the forest

```{r dt_lit_2, echo=FALSE, cache=TRUE, message=FALSE, warning=FALSE, comment=NA } 
    library(xtable)
    ml_dir = '../ml_lit/data/decision_tree_WOS'
    files <- dir(ml_dir,full.names=TRUE, pattern='savedrecs.*')
    recs <-lapply(files, read.csv, sep='\t', header=TRUE, as.is=TRUE, quote='', row.names=NULL)  
    ml_df <-do.call( rbind, recs )
    colnames(ml_df)[1:52] <- colnames(ml_df)[2:53]
    colnames(ml_df)[1] <-'PT'
    ml_df = ml_df[order(ml_df$TC, decreasing=TRUE),]
    print(xtable(head(ml_df[,c('TI', 'TC')])))
```


[@breiman_cart_1984]  is a comet-like publication in the machine learning literature. A  minor decision tree literature trails in the wake of its formalised treatment of construction and shaping of classification and regression trees.  This prolixity or associativity of decision trees can be seen in the scientific literature from the mid-1980s onwards. Decision trees again accelerate across behavioural, biomedical and associated statistical sciences.  A Thomson Reuters 'Web of Science' query on 'decision tree' across all indexes returns roughly 10,000 results, but most of these appear in the wake of [@breiman_cart_1984]. Just looking at the most highly cited results in this set, we can see that 'decision tree' plays a role in a psychiatric diagnostic procedure in 1992, in clinical decision making in 1993,  in helping sort out astronomical observations in 2000, in a serum protein matching test for distinguishing benign and non-benign prostate cancer in 2002,  or in bringing biometric data together to uniquely identify individuals in 2003. (A similar but more restricted Web of Science query on `CART` itself, the software developed by Jerome Friedman for the 1984 book _Classification and Regression Trees_ yields 1600 results, and the fields of application are just as varied.) While the most cited paper (the psychiatric diagnostic test) does not actually use machine learning, all the others do, and in greatly varying ways. The question then is how such a huge lateral slippage  occurring? What is it about decision trees that allows them to move across different settings so readily?

When we track the movement of techniques, whether in the form of algorithms, software implementations, embodied skills,  devices and their uses, I would argue that there is always something in the technique itself that animates its movement. This is to treat techniques like decision trees as if they were a form of life, with their own specificity and their own materiality. We have seen one side of this already: the statistical and algorithmic formalization of the 1960s decision tree work from the late 1970s onwards adds an increasing number of moving parts to the technique in the form of mathematical functions, splitting rules, measures of tree purity and feature importance, all of which are meant to allow the technique to deal with heterogeneous variations in data. Not only does the data become higher dimensional over these decades, but the techniques do too. But the more primary impetus to movement comes from the technique itself.  In _Alien Phenomenology_, Ian Bogost puts this point in  terms of 'unit operations':

> Objects try to make sense of each other through the qualities and logics they possess. When one object caricatures another, the first grasps the second in abstract, enough for the one to make some sense of the other given its own internal properties [@bogost_alien_2012, 66]

Like logistic regression models, artificial neural networks, support vector machines or any other machine learning technique, decision trees have certain qualities and logics, and they make sense of the worlds they encounter in terms of those qualities and logics. We have been discussed the node and tree impurity measures that guide splitting in trees. The quality of decision trees as classifiers Although these splitting rules have strong statistical justifications, they do not at all eliminate the problem of instability in trees. For instance, they easily end up 'overfitting' the data. Overfitting is a problem for all machine learning techniques. Algorithms sometimes find it hard to know when to stop. During construction of a decision tree, various features in the data are split into smaller and smaller groups. ''The goodness of the split', wrote Breiman and co-authors, 'is defined to be the decrease in impurity' [@breiman_cart_1984, 25]. Under this definition of goodness, the terminal nodes or leaves of the tree can end up containing a single case, or a single class of cases. The decision tree respects the singularity of the individual case to such a degree that it sees differences everywhere. Driven too maximise the purity of the nodes it creates, it leans heavily on  data it has been trained on to see relevant similarities when fresh data appears. Trees that branch too much are too sensitive (or unstable), and need to be pruned. An associated literature on pruning decision trees using measures of tree complexity has also developed.  _The Elements of Statistical Learning_ asks, 'how large should we grow the tree? Clearly a large tree might overfit the data, while a small tree might not capture the important structure. Tree size is a tuning parameter governing the model's complexity, and the optimal tree size should be adaptively chosen from the data' [@hastie_elements_2009,  307-308]. All of these questions and problems relate to the core test of any machine learning algorithm: does it generalize well?

Decision trees  also deliver some fresh problems of interpretation.  The look of a tree is not to be trusted: 'how a tree _looks_, complex, simple or something in between, is not a reliable indication of its predictive ability' [@malley_statistical_2011, 125].  Indeed  _The Elements of Statistical Learning_ warns us: 

> One major problem with trees is their high variance. Often a small change in the data can result in a very different series of splits, making interpretation somewhat precarious. The major reason for this instability is the hierarchical nature of the process: the effect of an error in the top split is propagated down to all of the splits below it.  312
@steinberg_cart_2009

While easy to intepret, decision tree interpretations can easily diverge. This divergence heavily affects their predictive power, and hence their capacity to engage in changing matters of fact in the world.  At the same time, the top splits in made by a tree at its root are not necessarily the most important ones in terms of prediction. Malley conclude that 'what a tree does at the very top is almost certainly not a good way to assess how it does by the time it gets to the bottom. And it is only at the bottom, where the terminal nodes appears, that the tree is making decisions on new cases' [@malley_statistical_2011, 136]. Many subtle variations and divergences affect trees, and they all attempt address problems of mobilization and generalization of the technique. 

Yet all of this modification, reconfiguration, tuning and tweaking of decision trees was subsumed by another form of movement -- the automation of the construction of trees through machine learning itself. In a move that I would suggest is symptomatic of the machine learning, the construction of trees using splitting rules and measures of node impurity, and then their subsequent pruning using measures of tree complexity was swept away by techniques such as Random Forests(TM).  Around 2001, Leo Breiman writes: 

> A random forest is a classifier consisting of a collection of tree-structured classifiers $\{h(x, \Theta_k ), k = 1, . . .\}$ where the $\{ \Theta_k \}$ are independent identically distributed random vectors and each tree casts a unit vote for the most popular class at input $\mathbf{x}$. [@breiman_random_2001, 6]

If we refer back to the formal definition of a classifier in _Classification and Regression Trees_  fifteen years earlier, there ares some suble but important transformations here: 

> A classifier or classification rule is a function $d(\mathbf{x})$ defined on $\mathcal{X}$ so that for every $\mathbf{x}$, $d(\mathbf{x})$ is equal to one of the numbers $1, 2, ..., J$. [@breiman_cart_1984, 4]

Breiman has added something that was not present in any of the previous definitions of decision trees, whether they were produced by `CART`, `ID3` or `C4.5` (Quinlan's popular techniques of constructing trees): 'independently identically distributed random vectors.' This has a strongly statistical tone, and brings  a series of developments in several decades of research into statistical inference to bear on the problem of classification. Again attention to small details in mathematical typography can illuminate these shifts: the presence of the curly bracks $\{\}$ points to the existence of a _set_ or collection; the capitalised Greek letter $\Theta$ in statistical texts normal attests to something that has a multiple and often somewhat probabilistic mode of existence (in a later chapter I discuss probability and statistical distributions in much more detail). 

How does this injection of statistical techniques based on 'independent identically distributed random vectors' change machine learning? From the earlier decision tree techniques of the 1960s  -- the Automatic Interaction Detector and the Concept Learning System - automated repetition of tree construction had been central. In the early 1980s work, this automation was refined and reshaped by a certain amount of formalism -- the introduction of functions such as the Gini diversity index and measures of information entropy ('cross-entropy' [@hastie_elements_2009, 309]). Some measures arrived via statistics, and others via information theory and computer science. Random forests and similar methods developed in the 1990s added a second level of formalisation working to reduce the _variance_ or the 'spread' of the predictions produced by decision trees. Practically, techniques based on practices of either _bagging_ or _boosting_ all bring a further level of recursivity to machine learning techniques. The random forest algorithm constructs a large number of shallow decision trees by randomly sampling a subset of variables as the basis of a tree and then building the tree. As Breiman writes: 'The forests studied here consist of using randomly selected inputs or combinations of inputs at each node to grow each tree' [@breiman_random_2001, 10].  

```{r titanic, echo=TRUE, cache=TRUE, message=FALSE, warning=FALSE, comment=NA } 
    library(randomForest)
    titanic_train = read.csv('data/titanic_train.csv')
    titanic_test = read.csv('data/titanic_test.csv')
    head(titanic_train)
    titanic_rp = rpart(Survived~Sex+Age+SibSp+Parch+Pclass + Fare+Embarked, titanic_train)    
    summary(titanic_rp)
    plot(titanic_rp)
    text(titanic_rp, cex=0.8, use.n=TRUE)

    titanic_train_r = na.omit(titanic_train)
    titanic_train_r$Survived = factor(titanic_train_r$Survived)
    titanic_rf=randomForest(Survived~Sex+Age+SibSp+Pclass + Parch+Fare+Embarked, titanic_train_r, proximity=TRUE)
    print(titanic_rf)
    print(round(importance(titanic_rf), 2))
    MDSplot(fac=titanic_train_r$Survived, titanic_rf, palette = c('red', 'green'))

```
This process is illustrated by the output of the `R` library `randomForest` at work on the `titanic` data, a dataset whose provenance and character I will discuss in greater detail in the next chapter. In this example, both a decision tree and a random forest classify the passengers of the titanic according to whether they survived or not.  The dataset is not very large as it only includes `r dim(titanic_train)[1]` passengers.  The decision tree chooses to split according to `r titanic_rp$variable.importance`. In the decision tree, `sex` and `fare` are followed by `pclass`, the passenger class.  The random forest model suggests that sex, followed by amount of fare paid, then age, then passenger class are the most important predictors of survival versus non-survivors from the Titanic: `r titanic_rf$importance`. How is it that the importance of variables can shift as we move from tree to forest? 

The summary of the titanic random forest refers to 500 decision trees, and it also reports that it chose two of the six variables in the dataset in constructing each tree. How can these reduced decision trees produce better predictions, such that random forests have become one of the most popular machine learning models?  The so-called 'proximity plot' for the random forest grown on the `titanic` data suggests something of what happens here. As Hastie et. al. comment, 'the idea is that even though the data may be high-dimensional, involved mixed variables, etc., the promixity plot gives an indication of which observations are effectively close together in the eyes of the random forest classifier' [@hastie_elements_2009, 595]. With this plot, it seems that patterns do start to emerge from the data that might be helpful in understanding what happened in a situation. 

Breiman attributes the strength of random forests to classify without overfitting to  the interplay between two dynamics:

> For random forests, an upper bound can be derived for the generalization error in terms of two parameters that are measures of how accurate the individual classifiers are and of the dependence between them. The interplay between these two gives the foundation for understanding the workings of random forests.  [@breiman_random_2001, 7]

In comparison to the decision trees, with their propensity to partition differences _ad absurdem_, random forests do not overfit because they  combine two different forms of movement. On the one hand, the sheer number of trees multiplies the chances that a good proportion of the trees will find a relevant pattern in the data. On the other hand, the de-coupling or lack of correlation between the trees helps ensure that the trees will provide independent views on the classification. Together these two features of the ensemble of decision allow random forests to 'generalize'  or, put more technically, to minimize the 'generalization error.'

> Our results indicate that better (lower generalization error) random forests have lower correlation between classifiers and higher strength. The randomness used in tree construction has to aim for low correlation $\overline{\rho}$ while maintaining reasonable strength [@breiman_random_2001, 20].

As in much machine learning, better means lower error rates. But here, the key point is that the components of the machine themselves appear to become statistical processes. That is, their construction is guided by the Law of Large Numbers (that is, 'the _law of large numbers_ says that the sample average $\overline{X}_n = n^-1\sum_{i=1}^nX_i$ converges in probability to the expectation $\mu = \mathbb{E}X_i$. This means that $X_n$ is close to $\mu$ with high probability ' [@wasserman_all_2003, 72]).  The injection of randomness, as Breiman terms it (10), only relates to certain aspects of the data and the components. It randomly selects small groups of features to use, and it randomly selects a subset of the training data. 

[TBA  - the explosive uptake of randomForest in 2006-7: explosive growth of random forests]


## Support vector machine and infinite dimensionality

The second most highly cited reference in the last few decades of machine learning literature is a paper by Corinna Cortes and Vladimir Vapnik of AT & T Bell Labs in New Jersey, USA entitled 'Support Vector Networks' [@cortes_support-vector_1995].  Few women's names have appeared prominently in the machine learning literature. The computing science and statistics departments at Stanford and Berkeley, the laboratories at Los Alamos and AT&T Bell between the 1960s and the 1980s were, it seems, not overly popular or populated with women scientists and engineers. Some prominent machine learning researchers at the time of writing are women, but Cortes is perhaps the most visible, both as head of Google Research in New York and as recipient with Vapnik of an Association for Computing Machine award in 2008  for their work on the support vector machine algorithm.  

```{r pattern_recognition1, echo=TRUE, cache=TRUE, message=FALSE, warning=FALSE, comment=NA, size='smallsize', results='asis' } 
    dir = '../ml_lit/data/pattern_recognition_WOS'
    files <- dir(dir,full.names=TRUE, pattern='savedrecs.*')
    recs <-lapply(files, read.csv, sep='\t', header=TRUE, as.is=TRUE, quote='', row.names=NULL)  
    df <-do.call( rbind, recs )
    colnames(df)[1:52] <- colnames(df)[2:53]
    colnames(df)[1] <-'PT'
    df = df[order(df$TC, decreasing=TRUE),]
    print(head(df$TI))
```

The rapid rise to popularity of the support vector machine can be seen in the machine research literature. A substantial fraction of the overall research output is linked to this single technique. The influence of the technique  can also be seen in  adjacent and overlapping fields such as pattern recognition and data mining, where [@cortes_support-vector_1995] and similar paper ranks near the top-cited papers. This kind of growth betokens high levels of interest, identification and investment on the part of the researchers, and presumably more widely. What is it about this technique?

If the shift from decision trees to random forests illustrate an increasingly statistical movement in machine learning, propelled by controlled injections of randomness,  the support vector machine, demonstrates a different way of coping with the problems of generalization.  It is difficult to overstate the importance of support vector machine. While the name is somewhat forbiddingly technical compared to more easily understood terms such as 'decision tree' or 'neural network,' the underlying intuition of the technique is much older, and can be found in the models developed by the British statistician R. A. Fisher. R.A Fisher developed the 'first pattern recognition algorithm' [@cortes_support-vector_1995, 273], the 'linear discriminator function' [@fisher_use_1936],  to deal with problems of classification, and demonstrated its efficacy on the taxonomic problem of  discriminating W.E. Anderson's irises. In his article in the _Annual Review of Eugenics_, Fisher commented on similar classification work carried out in craniometry and other related settings: so-called 'disciminant functions' had been successfully used to distinguish populations. Fisher wrote: 'when two or more populations have been measured in several characters, ... special interest attaches to certain linear functions of measurements by which the populations are best disciminated' [@fisher_use_1936, 179].  The route by which these long-standing disciminant functions were reconstructed during the 1990s in the form of the support vector machine is of interest, because it brings to light an important form of movement in  contemporary data. This movement we might call _infinitist_ because it opens up the possibility of locating data in infinite dimensional spaces in pursuit of modes of existence of lines and planes that would otherwise appear.

The support vector machine, as we will see, powerfully exemplifies this expansive form of generalisation. In the abstract of their 1995 paper, Cortes and Vapnik briefly describe the support vector machine:

> The support-vector network is a new learning machine for two-group classification problems. The machine conceptually implements the following idea: input vectors are non-linearly mapped to a very high-dimension feature space. In this feature space a linear decision surface is constructed [@cortes_support-vector_1995, 273]

Note that this 'very high-dimension feature space' is explicitly made to support 'a linear decision surface.' This 'linear decision surface' is an old and familiar entity in statistics. It had been proposed by Fisher as a way of separating or disciminating populations (with all the resonances that the term 'discriminate' carry, especially given that Fisher was writing in 1936) .The vector space model of data encourages a certain form of classification -- the search for the best line, the line of best fit, or the most discriminating line, the line that best divides things from each other. Linear regression is not called 'linear' for no reason. And Fisher's 'discriminant functions' were later called 'linear discriminant analysis' for the same reason (TBA: see chapter x of Hastie): they divide the vector space into different regions ('decision regions') separated by 'decision boundaries' [@alpaydin_introduction_2010, 53]. Clearly there is a massive idealisation of classification and prediction here. The Platonic form of the line, the plane, and sometimes the sphere, function as ideal forms to which  actual processes, events and practices can only approximate. This idealism of the perfect plane, however, is something that almost the entire gamut of machine learning techniques are aware of, since it is largely concerned with optimisation and control of errors or risk rather than insistence on underlying regularity, norm or law. And, as we saw in the previous chapter, the commitment to machine learning as a technique of function approximation or function estimation exposes the field to an indefinite variety of different functions and forms, many of which are non-linear.  

Despite the in-principle commitment to any form of function, machine learning like statistics retains strong preferences for forms that can either be visualised on a plane (using the visual grammar of lines, dots, axes, labels, colours, shapes, etc), or can be computed in form of matrix or vectorised calculationsIn many ways (see chapter two on this point). Many of the techniques that grapple with complicated datasets seek to reduce their dimensionality so that lines, planes and regular curves can be applied to them: multi-dimensional scaling (MDS),  factor analysis, principal component analysis (PCA), self-organising maps (SOM) are just a few examples of this (the MDS plot of the _Titanic_ data as modelled by a random forest above is an example of this dimensional reduction).  The last three decades of research in machine learning, whether it has been primarily statistical, mathematical, or computational, mainly countenances  and addresses problems of relationality through _dimensional reduction_.  

But certain techniques, such as support vector machines, buck this trend. They have  increased the dimensionality of the predictive  model in order to construct higher-order forms of linearity inside the ostensibly non-linear messiness of the data.   As Vapnik writes in the preface to the second edition of _The Nature of Statistical Learning Theory_ [@vapnik_nature_1999, vii], 'in contrast to classical methods of statistics where in order to control performance one decreases the dimensionality of a feature space, the SVM dramatically increases dimensionality and relies on the so-called large margin factor' (vii). Nearly all expositions of the support vector machine including [@cortes_support-vector_1995] begin with an illustration of a 'separable problem' and the 'maximum margin separating hyperplane.'

```{r separating_hyperplane, echo=FALSE, cache=TRUE, message=FALSE, warning=FALSE, comment=NA, engine='python' } 

import numpy as np
import pylab as pl
import seaborn
from sklearn import svm

np.random.seed(0)
X = np.r_[np.random.randn(20, 2) - [2, 2], np.random.randn(20, 2) + [2, 2]]
Y = [0] * 20 + [1] * 20

clf = svm.SVC(kernel='linear')
clf.fit(X, Y)

w = clf.coef_[0]
a = -w[0] / w[1]
xx = np.linspace(-5, 5)
yy = a * xx - (clf.intercept_[0]) / w[1]

b = clf.support_vectors_[0]
yy_down = a * xx + (b[1] - a * b[0])
b = clf.support_vectors_[-1]
yy_up = a * xx + (b[1] - a * b[0])

pl.plot(xx, yy, 'k-')
pl.plot(xx, yy_down, 'k--')
pl.plot(xx, yy_up, 'k--')

pl.scatter(clf.support_vectors_[:, 0], clf.support_vectors_[:, 1],
           s=80, facecolors='none')
pl.scatter(X[:, 0], X[:, 1], c=Y, cmap=pl.cm.Paired)

pl.axis('tight')
pl.savefig('/figure/separating_hyperplane.png', dpi=400)
print('![Separating hyperplane](figure/separating_hyperplane.png)')

```

Perhaps the extraordinary proliferation of support vector machines can be analysed in these terms. Up to and including 2000, the technique is largely discussed in generic terms of machine learning, classification and data-mining. But each year after that, a stunning variety of new concerns are associated with the support vector machine.  In 2001 alone, the application of support vector machine grows explosively. 

```{r svm_growth, echo=FALSE, cache=TRUE, message=FALSE, warning=FALSE, comment=NA, engine='python'} 
import ml_lit_anal as ml
import re
import nltk
import pickle
import operator
import pandas as pd
import networkx as nx
import itertools
import matplotlib.pyplot as plt
import numpy as np

df = ml.load_records('../ml_lit/data/machine_learning_WOS/')
df = ml.clean_topics(df)

svm_df = ml.keyword_years(df, 'support vector|support vector machine.?|svm|support vector network.?')
svm_nx_2001= ml.term_year_network(df = svm_df, topic = 'support vector machine', start=2000, end = 2001, plot=False)
svm_nx_2002= ml.term_year_network(df = svm_df, topic = 'support vector machine', start=2001, end = 2002, plot=False)

plt.figure(figsize=(20,20))

plt.subplot(131)
plt.title('')
nx.draw_graphviz(svm_nx_2001, with_labels=True, 
                     alpha = 0.8, width=0.1,
                     labels = nx.get_node_attributes(svm_nx_2001, 'topic'),
                     fontsize=9,
                     node_size = [s*4500 for s in nx.eigenvector_centrality(svm_nx_2001).values()],
                     node_color = [s for s in nx.degree(svm_nx_2001).values()])

plt.subplot(122)
nx.draw_graphviz(svm_nx_2002, with_labels=True, 
                     alpha = 0.8, width=0.1,
                     labels = nx.get_node_attributes(svm_nx_2002, 'topic'),
                     fontsize=10,
                     font_family = 'sans serif',
                     node_size = [s*4500 for s in nx.eigenvector_centrality(svm_nx_2002).values()],
                     node_color = [s for s in nx.degree(svm_nx_2002).values()])

plt.savefig('figure/svm_2000_2001.png', dpi=400)
print('![Growth of svm topics 2000-2001](figure/svm_2000_2001.png)')
```

The graphs shown above contrast support vector machines in the machine learning literature at 2000 and 2001. In the topic network on the left, the generic topics associated with support vector machines appear. By contrast, the topic network for 2001-2 has grown rapidly to include classification problems concerned with images, fraud detection, river flow, protein structure and user-profiling. The growth in topics of application quickly becomes difficult to graph as topics associate contagiously across the physical, life, health and business sciences. In publications appearing 2001-2002, the blood brain barrier, breast cancer, prostate cancer, and drug activity have become prominent. By 2012, topics have span stock markets, optometry, mammography and cumene synthesis.  Decision trees show similar patterns of proliferation, but their growth spans decades not a few years. It seems that this exuberant application of support vector machines must have been addressing some kind of shared problematization. Here I  want to suggest that the technique itself provides a lead. It opens a path of least resistance for movement amidst data. In particular, an increase in 'the dimensionality of the feature space'  is attractive because it suggests that more complicated datasets could be modelled and classified with trying to find ways of first distilling the dataset down to its most important features. 

## Support vectors and non-linear margins

A simple illustration of how the support vector machine works with data appears in Cortes and Vapnik's initial publication [@cortes_support-vector_1995]. They demonstrate how the support vector machine classifies handwritten digits drawn from a dataset supplied by the US Postal Service. Like _iris_ , the US Postal Service digits and a larger version from the US National Institute of Standard (NIST) are  standard machine learning dataset, frequently used to measure the performance of different learning algorithms. In contrast to _iris, the US Postal Service Database is high dimensional. Each digit in the dataset is stored as 16x16 pixel element. Image classification typically treats each pixel as a feature  or variable in the input space. So each digit as represented by a 16x16 pixels amounts to a 256 dimensional input space. _Iris_ by comparison has five dimensions. Unsurprisingly, there are also many more digits in the US Postal Service Database than in flowers in _iris_:10,000. The NIST dataset has around 70,000. Aside from this dimensional growth, the handwritten digits aptly convey the non-linearity of the classification problem. On the one hand, human can recognise handwritten digits fairly easily and with few errors. This is despite the many variations in handwriting that skew, morph and distort the ideal graphic forms of numbers. Differences in writing were not only an impetus for deconstructionist theory in the 1980-90s. They were also actively being modelled in machine learning. 

In their experiments with digit recognition, Cortes and Vapnik contrast the error rates of decision trees (CART and C4.5), neural networks and the support vector machine working at various level of dimensionality. I am not going to track through the workings of the support vector machine. They are mathematically complicated compared to decision trees or random forests. But Cortes and Vapnik highlight the growth in dimensionality introduced by the technique of the support vector in ways that I find evocative. They describe how the technique exponentially increases the dimensionality of the feature space and how the error rate on difficult to classify handwritten digits drops correspondingly. When the feature space has 256 dimensions (the given dimensions of the 16x16 pixel digits), the error rate is around 12%. As the dimensionality grows to 33,000, then a million, a billon, a trillion and so forth (up to $1 x 10^16$ dimensions), the error rate dorps to just over 4%, which is close to the errors made by 'human performance' (2.5%) [@cortes_support-vector_1995, 288].  

How does the support vector machine increase the dimensionality so drastically without either runnning into a computational deadlock or worse, massively overfitting the data, resulting in poor generalization?  The technique of 'mapping the input vectors into some high dimensional feature space $Z$' [@cortes_support-vector_1995, 274] has long standing roots in the field of pattern recognition.  Remember that the problem is how to deal with patterns of data that cannot be separated by a line or plane. As mentioned above, the idea is construct a new vector space based on a transformation of the  data, and then in that higher dimensional space, finding a (hyper)plane that best separates different classes of data (the optimal hyperplane). The synthetic dataset shown at the beginning of this chapter illustrates the visual problem. It is hard to see on the plot of that data where a line could be drawn that separates different coloured data points from each other. If they were transformed into a higher dimensional space, would a line be easier to draw? In principle it should be. This is a long-standing item of faith in pattern recognition ('the underlying justification can be found in _Cover's theorem_ on the separability of patterns; that is, a complex pattern classification problem case in a high-dimensional space is _more likely_ to be linearly separable than in a low dimensional space' [@wu_top_2008, 42]). 

```{r svm-demo, echo=TRUE, cache=TRUE, message=FALSE, warning=FALSE, comment=NA, engine='python' } 
    import numpy as np
    import pylab as pl
    import seaborn
    from sklearn import svm, datasets

    iris = datasets.load_iris()   # import some data to play with
    X = iris.data[:, :2]  # we only take the first two features. We could  avoid this ugly slicing by using a two-dim dataset
    Y = iris.target

    h = .02  # step size in the mesh

    C = 1.0  # SVM regularization parameter
    svc = svm.SVC(kernel='linear', C=C).fit(X, Y)
    rbf_svc = svm.SVC(kernel='rbf', gamma=0.7, C=C).fit(X, Y)
    poly_svc = svm.SVC(kernel='poly', degree=3, C=C).fit(X, Y)
    lin_svc = svm.LinearSVC(C=C).fit(X, Y)

    x_min, x_max = X[:, 0].min() - 1, X[:, 0].max() + 1
    y_min, y_max = X[:, 1].min() - 1, X[:, 1].max() + 1
    xx, yy = np.meshgrid(np.arange(x_min, x_max, h),
                         np.arange(y_min, y_max, h))

    titles = ['SVC with linear kernel',
              'SVC with RBF kernel',
              'SVC with polynomial (degree 3) kernel',
              'LinearSVC (linear kernel)']


    for i, clf in enumerate((svc, rbf_svc, poly_svc, lin_svc)):
        pl.subplot(2, 2, i + 1)
        Z = clf.predict(np.c_[xx.ravel(), yy.ravel()])

        Z = Z.reshape(xx.shape)
        pl.contourf(xx, yy, Z, cmap=pl.cm.Paired)
        pl.axis('off')

        pl.scatter(X[:, 0], X[:, 1], c=Y, cmap=pl.cm.Paired)

        pl.title(titles[i])

    pl.show()
```
A part of me thinks that this justification for the support vector machine has to be right. It points to the importance of locality in pattern. Patterns inherently distribute differences. The form of movement engineered into various machine learning techniques grapple with the distribution of differences. But they do it in different ways. Sometimes that take for granted the possibility of separation in a pattern, as if the pattern itself was intrinsically divisible or cleavable along certain lines or contours. At other times, intrinsic inseparability is taken into account as part of the learning.  The power of support vector machine to do this is limited, but instructive. It can deal with various forms of inseparability and non-linearity by taking the difficult-to-classify boundary cases as the basis of the model. The so-called 'support vectors' lie on the decision hyperplane or surface, and effectively define its orientation and shape in the vector space of the data.  

## The qualities of an algorithm

The support vector machine is distinctive in its mode of movement, and without being swamped by the technical details, we might grasp something of this from Vapnik's writings. Vapnik trained and worked of decades in the former USSR as a mathematician and statistician. His writings on the problems of pattern recognition contrast greatly with other engineers, statisticians and computer scientists  in their  robustly theoretical formalism. A highly cited 1971 publication with  Alexey Chervonenkis 'On the uniform convergence of relative frequencies of events to their probabilities' (published in Russian in 1968 ) [@vapnik_uniform_1971] sets the tone of this work. In ensuing publications in Russian and then in English after Vapnik moved from Moscow to AT&T's New Jersey Bell Labs in 1990, Vapnik's work remains  mathematical and abstract. Although it pertains to 'learning machines,' machine here are understood in mathematically simply as 'the implementation of a set of functions' [@vapnik_nature_1999, 17]. The way that Vapniks develops a theory of learning owes little visible debt to actual attempts to work with data or experience in doing statistics in an particular domain. This contrasts greatly for instance with the work of statisticians like Breiman or Friedman or even computer scientists like Quinlan whose work lies much closer to fields of application.  Vapnik's work, like that of the Russian mathematician Andrey Kolmogorov he draws on, differs from many other contributions to machine learning partly by virtue of this formality and its efforts to derive insight into machine learning by theorising learning. The _Vapnik-Chervonenkis dimension_( VC dimension), a very widely used way of defining the capacity of a particular machine learning technique to recognise patterns in data dates from his work in the 1960s and underpins a general theory of 'learning.' Vapnik writes in 1995, 

> The VC dimension of the set of functions (rather than the number of parameters) is responsible for the generalization ability of learning machines. This opens remarkable opportunities to overcome the "curse of dimensionality [@vapnik_nature_1999, 83].

TBC: main points -

- intuition of the maximum margin separating hyperplane and how support vectors help;
- non-separable classification -- soft margin and what the support vectors do
- non-linear classification -- the kernel trick -- remapping the input space into the feature space via the kernel trick
- kernel trick -- highly formal result -- Hilbert space  -- combined with pragmatic concern with multiplying dot products ... 
- Breiman on localities in data -- support vector helps do that
- Whitehead on patterns  - >Perhaps our knowledge is distorted unless we can comprehend its essential connection with happenings which involve spatial relationships of fifteen dimensions. W, MoT, 78

```{r svm_non_linear2, echo=TRUE, cache=TRUE, message=FALSE, warning=FALSE, comment=NA , engine='python'} 
import numpy as np
import pylab as pl
from sklearn import svm

xx, yy = np.meshgrid(np.linspace(-3, 3, 500),
                     np.linspace(-3, 3, 500))
np.random.seed(0)
X = np.random.randn(300, 2)
Y = np.logical_xor(X[:, 0] > 0, X[:, 1] > 0)

clf = svm.NuSVC()
clf.fit(X, Y)


Z = clf.decision_function(np.c_[xx.ravel(), yy.ravel()])
Z = Z.reshape(xx.shape)

pl.imshow(Z, interpolation='nearest',
          extent=(xx.min(), xx.max(), yy.min(), yy.max()), aspect='auto',
          origin='lower', cmap=pl.cm.PuOr_r)
contours = pl.contour(xx, yy, Z, levels=[0], linewidths=2,
                      linetypes='--')
pl.scatter(X[:, 0], X[:, 1], s=30, c=Y, cmap=pl.cm.Paired)
pl.xticks(())
pl.yticks(())
pl.axis([-3, 3, -3, 3])
pl.show()
pl.savefig(dpi=400, 'figure/svm_non_linear2.png')
print("![non-linear svm]('figure/svm_non_linear2.png')")
```

> For these machines, the support vectors are the critical elements of the training set. They lie closest to the decision boundary; if all other training points were removed (or moved around, but so as not to cross H1 or H2 ), and training was repeated, the same separating hyperplane would be found. [@burges_tutorial_1998, 131]

> A machine with too much capacity is like a botanist with a photographic memory who, when presented with a new tree, concludes that it is not a tree because it has a different number of leaves from anything she has seen before; a machine with too little capacity is like the botanist’s lazy brother, who declares that if it’s green, it’s a tree. Neither can generalize well. The exploration and formalization of these concepts has resulted in one of the shining peaks of the theory of statistical learning (Vapnik, 1979). [@burges_tutorial_1998, 122]

>  The kernel trick is another commonly used technique to solve linearly inseparable problems. This issue is to define an appropriate kernel function based on the _inner product_ between the given data, as a nonlinear transformation of data from the input space to a feature space with higher (even infinite) dimension in order to make the problems linearly separable. {@wu_top_2008, 42]


[TBC -- how it works, but why does it matter? Need to do something more than give a textbook description here -- what are we doing when we describe techniques like this? ]

How could  one increase the dimensionality of the feature space without massively complicating the model?
TBA -- this section has to deal with the idealism of the plane vs the curviness of the kernel
It also has to bring in ANW on the pattern  ....


## Conclusion

As anyone would expect, the various techniques we have just been discussing -- decision trees, random forests, linear discriminant analysis and support vector machines -- have changed over time. As we've seen, in many cases newer techniques can be seen as recursive applications of earlier artificial intelligence, pattern recognitio or statistical techniques to themselves. The random forest is a higher level formalization of the many decision trees. The decision tree itself algorithmically formalizes earlier hierarchical classification techniques. Similarly, the support vector machine takes the idea of the separating hyperplane or the discriminant function and flips the data into a many dimensional space in order to find the linear discriminant function or separating plane there.  But across all these conversions, transformations, formalizations and automations, whether buoyed up injections of probabilistic reasoning and randomness or broad ranging theories  of learning processes and gener, one assumption remains almost completely intact: that the process that generated the data itself does not change.  In slightly more philosophical terms, the exuberant multiplication of dimensions in the data opens up huge internal vistas, canyons and paths through the data, but cannot countenance becoming in data.  At the same time, and perhaps machine learning is not  at all unusual in this, its own becoming is largely a puzzling encumbrance to it. Could machine learning learning to make sense of itself as anything other than an increasingly powerful mobilisation of techniques? 

There is some grounds on which we might think about this differently. Often machine learning techniques have multiple incarnations and tangled genealogies. Decision trees demonstrate this kind of phylogeny. The statistical trajectory of their development moves in a different way to the artificial intelligence/computer science version. Even if they end up appearing almost interchangeable in the contemporary data mining literature, the classification trees developed by Friedman/Breiman/Olshen  have a different mode of existence to the ID3/C4.5 decision trees developed by computer scientists such as Quinlan.  Similarly, the kind of probabilistic scaffolding that random forests adds to decision trees is quite distinct from the incorporation by Vapnik of infinite dimensional spaces via the mathematics of kernel functions.  By virtue of these different paths of development, and in the light of the very different modes of moving through data they entail, machine learning techniques themselves incorporate the world in specific ways.  

At the beginning of this chapter, I proposed we should approach the forest of techniques and practices associated with machine learning by thinking about them in terms of movement. That is, each technique should be seen as a form of movement through a high-dimensional space. That adheres fairly closely to the way that the machine learning literature itself present techniques. The literature grapples constantly with dimensionality. It multifariously attempts to reduce, extract, separate, or decompose the dimensionality of data, and does this in the name of classification, prediction and above all, generalization. In every case, the technique is defined by a dataset whose dimensions may be large, but whose As machine learning techniques themselves n

But  do these differences in architecture or provenance matter given a massive and often seemingly crushing assimilation of data in the server farms of network media and large enterprises, or in commercial and government surveillance programs? There are massive disparities in scale here. The analytic or predictive power of the US National Security Agency, Google Search, Fico's credit-worthiness systems, or certain financial trading systems heavily blankets the terrain. These apparatuses are not, I would suggest, easily steered by any persons since the appetite of machine learning for diverse data seems to immediately override existing limits or constraints. But even just understanding the  form of movements through the data we in classification trees, random forests and in support vector machines might help position us differently in relation to these voracious systems. It is hard to know exactly what they are doing, but I'm fairly strongly persuaded that they do not do anything radically different from what we can see in the machine learning literature I have been discussing. The technical expertise of engineers, statisticians and computer scientists are Google, Facebook, Walmart or the NSA has developed in and amongst the same forest of classification systems we encounter in that literature. The popularity of the support vector machine in the last decade is general. The proliferation of decision trees in the 1980s and then random forests in the 2000s is likewise general. These are techniques whose power to generalize generalizes them.  

Yet the various forms of movement I have delineated -- statistical, imitative and infinitist -- do not exhaust the potential forms of movement in data. In starting from a contrast between the two types of dataset -- a synthetic or articial dataset and a dataset lifted from the world (`iris,` `Titanic` or `NIST Handwritten Digits`) -- I assumed that data is given (as per the name 'data'). But I wonder increasingly whether data is given  in the sense of a finished act, or an event that has passed. It seems that everything we have discussed in relation to the techniques of the decision tree, the random forest, linear discriminant analysis or the support vector machine takes for granted that the model can exist in a time that comes after the data has been given. And that the patterns and dimensionality of data are more or less fixed for a given machine learner. But that is precisely what has turned out not to be the case. The generalization of machine learning in recent years  points in a different direction. The models themselves are undeniably if still somewhat impalpably living in our worlds in many different ways, ranging from the character recognition interface of touch screen through to the terrorist clique detection systems running on financial transactions.  What they encounter there is not and never has been of fixed dimensionality or  constant pattern. In this respect, the marvellous and for me often evocatively counter-intuitive developments in machine learning technique still fall short of what is in the data, the becomings, the gradients, the fluxes and local differences. Their movement is still not in the data enough. The question then is how to make sure that  models are not left to their own devices. How, as they become more and more part of how things happen, can they be  recomposed in the midst of things? In the next chapter, as I discuss machine learning competitions and the subjects/practictioners/technicians of optimisation, this ongoing recomposition will matter more.



